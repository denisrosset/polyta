package com.faacets
package polyta

import scala.{specialized => sp}

import spire.algebra._
import spire.math.Rational
import spire.syntax.action._
import spire.syntax.order._
import spire.syntax.innerProductSpace._
import spire.util._

import qalg.algebra._
import qalg.algos._
import qalg.syntax.all._
import qalg.syntax.indup.all._
import qalg.syntax.algos.all._

import net.alasc.algebra._
import net.alasc.math.{Perm, Grp}
import net.alasc.std.unit._

/*
// TODO: move to matrix storage
final class VPolytopeNoSym[M, V, @sp(Double, Long) A](val vertexPoints: M, val rayPoints: M)(implicit val pack: PackField.ForMV[M, V, A], val orderA: Order[A]) extends VPolytope[V, A] {
  require(vertexPoints.nCols == rayPoints.nCols)
  def nX = vertexPoints.nCols
  def vertices: Seq[Vertex] = new IndexedSeq[Vertex] {
    def length = vertexPoints.nRows
    def apply(i: Int): Vertex = new SingleVertex(vertexPoints(i, ::))
  }
  override def allVertices = vertices
  def rays: Seq[Ray] = new IndexedSeq[Ray] {
    def length = rayPoints.nRows
    def apply(i: Int): Ray = new SingleRay(rayPoints(i, ::))
  }
  override def allRays = rays
  object elementAction extends Action[Element, Unit] {
    def actl(g: Unit, e: Element): Element = e
    def actr(e: Element, g: Unit): Element = e
  }
  object vertexAction extends Action[Vertex, Unit] {
    def actl(g: Unit, v: Vertex): Vertex = v
    def actr(v: Vertex, g: Unit): Vertex = v
  }
  object rayAction extends Action[Ray, Unit] {
    def actl(g: Unit, r: Ray): Ray = r
    def actr(r: Ray, g: Unit): Ray = r
  }
  type Element = ElementBase[V]
  type Vertex = SingleVertex[V]
  type Ray = SingleRay[V]
  type G = Unit
  val symGroup: Grp[Unit] = Grp(())
  def symSubgroup(e: Element): Grp[G] = Grp(())
  override def flatten = this
}
 */
