package com.faacets
package polyta

import scala.{specialized => sp}

import spire.algebra._
import spire.math.Rational
import spire.syntax.cfor._
import spire.syntax.action._
import spire.syntax.vectorSpace._
import spire.util._

import qalg.algebra._
import qalg.algos._
import qalg.syntax.all._
import qalg.syntax.indup.all._
import qalg.syntax.algos.all._

import net.alasc.algebra._
import net.alasc.math.{Perm, Grp}
import net.alasc.std.unit._

final class HPolytopeNoSym[M, V, @sp(Double, Long) A](val mA: M, val vb: V, val mAeq: M, val vbeq: V)(implicit val pack: PackField.ForMV[M, V, A]) extends HPolytope[V, A] {
  require(mA.nCols == mAeq.nCols)
  def nX = mA.nCols
  def facets: Seq[Facet] = new IndexedSeq[Facet] {
    def length = mA.nRows
    def apply(i: Int): Facet = new Facet(LinearInequality(mA(i, ::), LE, vb(i)))
  }
  override def allFacets = facets
  def equalities: Seq[Equality] = new IndexedSeq[Equality] {
    def length = mAeq.nRows
    def apply(i: Int): Equality = LinearEquality(mAeq(i, ::), vbeq(i))
  }
  object action extends Action[Facet, Unit] {
    def actl(g: Unit, f: Facet): Facet = f
    def actr(f: Facet, g: Unit): Facet = f
  }
  type Facet = SingleFacet[V, A]
  type G = Unit
  val symGroup: Grp[Unit] = Grp(())
  def symSubgroup(f: Facet): Grp[G] = Grp(())
  override def flatten: HPolytope[V, A] = this
}
